;;;
;; Work-in-progress compiler for Lemma
;; Still needs:
;;  - Unsplice support in fn parameter vectors
;;  - More special forms:  expand
;;  - Support for metadata (and subsequently doc-strings)
;;  - Better error handling
;;  - Support for aliasing the builtins?  e.g.: (def lambda fn)
;;  - Probably other stuff I'm not thinking of right now...
;;;

(def format lua/string.format)

(def cur-ns :lemma)

;; Map f over xs, then return the concatenated results separated by commas
(defn comma-map [f xs]
  (let [strs (map (fn [a] (str (f a) ", ")) xs)]
    (lua/string.sub (str @strs) 1 -3)))  ; remove the trailing comma

(defn gen-quote [t]
  (fn [x] (str t "(" (comma-map rec-quote x) ")")))

;; Quote is like compile, but it follows a different evaluation strategy.
;; For self-evaluating forms, it delegates the work to compile.
(defn rec-quote [xs]
  (let [types {
    :Symbol   (fn [x] (str "Symbol(\"" (.string x) "\")"))
    :List     (gen-quote :List)
    :Vector   (gen-quote :Vector)
    }]
    (let [t (type xs)]
      (if (types t)
          ((types t) xs)
          (compile xs)))))

(defn handle-quote [xs]
  (rec-quote (first xs)))

(defn invert-quasiquote [xs]
  (if (= :List (type xs))
      (let [x (first xs)]
        (if (and (= :Symbol (type x))
                 (= :unquote (.string x)))
            (second xs)
            (cons 'lua/List (map invert-quasiquote xs))))
      `(quote ~xs)))

(defn handle-quasiquote [xs]
  (compile (second (invert-quasiquote xs))))

;; This needs to handle @args in the parameter vector
(defn handle-fn [xs]
  (let [args (first xs)
        body (rest  xs)]
    (sym-push)
      (let [hyperbanana ["(function("
                         (comma-map sym-new args)
                         ")\n"
                         @(map compile body)]]
        (lua/table.insert hyperbanana (length hyperbanana) "return ")
        (sym-pop)
        ; "\n-- function(" (comma-map (fn[x]x) args) ")\n"
        (str (lua/table.concat hyperbanana) "\nend)"))))

(def specials {
  :ns      (fn [xs]
             (let [ns (first xs)]
               (if (not (string? ns))
                 (lua/Error (str "ns: string expected (Got " (type ns) ")"))
                 (do
                   (set! cur-ns ns)
                   (str "lemma[\"*ns*\"] = " ns ";\n")))))
  :quote   handle-quote
  :quasiquote handle-quasiquote
  :def     (fn [xs]
             (let [k (first  xs)
                   v (second xs)]
               (let [local (if (= 0 (sym-len)) "" "local ")]
                 (str local (sym-new k) " = " (compile v) ";\n"))))
  :set!    (fn [xs]
             (let [k (first  xs)
                   v (second xs)]
               (str (sym-find k) " = " (compile v) ";\n")))
  :fn      handle-fn
  :macro   (fn [xs] (str "Macro" (handle-fn xs)))
  :cond    (fn [xs]
             (let [ks (odds  xs)
                   vs (evens xs)]
               (str "(function()\n"
                 "if (" (compile (first ks)) ") then\nreturn "
                      (compile (first vs))
                 @(map (fn [k v]
                         (str "\nelseif (" (compile k) ") then\nreturn "
                           (compile v)))
                         (rest ks)
                         (rest vs))
                 "\nend\nend)()\n")))
  })

(defn compile [exp]
  (let [types {
    :Number     (fn [x] (.string x))
    :string     (fn [x] (format "%q" x))
    :boolean    (fn [x] (if x :true :false))
    :Nil        (fn [x] :nil)
    :False      (fn [x] :false)
    :Vector     (fn [x] (str "Vectorize{"  (comma-map compile x) "}"))
    :HashMap    (fn [x]
                  (let [mems []]
                  ;; In the imperative style because map produces another hash
                  ;; but we want something we can concat.
                    (for-each (fn [a]
                                (lua/table.insert mems
                                                  (str "["
                                                       (compile (first a))
                                                       "] = "
                                                       (compile (second a))
                                                       ", ")))
                              x)
                    (str "Mapify{" @mems "}")))
    :PreHashMap (fn [x] (compile (lua/HashMap @x)))
    :Symbol     (fn [x] (sym-find x))
    :List       (fn [x]
                  (let [head (first x)]
                    (cond
                      (specials (.string head))
                        ((specials (.string head)) (rest x))
                      ;; Currently, macros only work if defined at top level
                      (= :Macro (type (lua/eval head lua/env)))
                        (let [f (get (lua/eval head lua/env) :func)]
                          (compile (f @(rest x))))
                      :else
                        (str (compile head) "("
                             (comma-map compile (rest x)) ")"))))
  }]
    (if (types (type exp))
      ((types (type exp)) exp)
      (str "-- Whoops! " exp` "\n"))))

(loop []
  (lua/io.write "\n> ")
  (let [code (compile (lua/read (lua/FileStream (lua/io.input)) true))]
    (print "-------")
    (print code)
    (print "-------")
    (let [f (lua/assert (lua/loadstring code))]
      (if (= :function (type f))
          (do
            (lua/io.write ";=> ")
            (f))
          (print f))))
  (recur))
