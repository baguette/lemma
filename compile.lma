
;; TODO: Macros, etc.

(def format lua/string.format)
(def concat lua/table.concat)
(def unpack lua/Seq.lib.unpack)
(def tostring lua/tostring)
(def type   lua/type)

;; Not exactly Clojure's mapcat, since this concat isn't exactly Clojure's
;; concat... return the string concatenation of a mapped seq
(defn mapcat [f @xs]
  (str (unpack (map f ,@xs))))

;; TODO: More specials?
(def specials {
    :def (fn [xs]
           (let [ks (odds  xs)
                 vs (evens xs)]
             (mapcat (fn [k v]
                      (format "local %s = %s\n" (compile k) (compile v)))
                    ks
                    vs)))
     :fn  (fn [xs]
            (let [args (first xs)
                  body (rest  xs)]
              (let [funstuff ["function("
                              (lua/string.sub (mapcat (fn [arg]
                                                        (format "%s, "
                                                          (compile arg)))
                                                      args)
                                              1
                                              -3)
                              ")\n"
                              (unpack (map compile body))
                              "\nend"]]
                (lua/table.insert funstuff (- (length funstuff) 1) "return ")
                (concat funstuff))))})

(defn compile [exp]
  (let [switch {
         :number   (fn [x] (format "%d " x))
         :string   (fn [x] (format "%q " x))
         :Symbol   (fn [x] (.string x))
         :boolean  (fn [x] (if x :true :false))
         :Nil      (fn [x] :nil)
         :Vector   (fn [x]
                     (str "{ "
                          (mapcat (fn [y]
                                    (str (compile y) ", "))
                                  x)
                          "} "))
         ;; TODO: Ideally, we'd be getting a PreHashMap from read()
         ;; (I think there's a problem in cons for HashMap... thus the
         ;;  set!)
         :HashMap  (fn [x]
                     (def t [])
                     (for-each (fn [y]
                                 (lua/table.insert t (str "[" (compile (first y)) "] = "
                                      (compile (second y)) ", ")))
                                x)
                     (str "{ "
                          (unpack t)
                          "} "))
         ;; TODO: List needs to handle function calls in addition to specials
         :List     (fn [x]
                     ;(print (lua/tostring (first x)))
                     (let [f (specials (lua/tostring (first x)))]
                       (if f (f (rest x)))))
       }]
     (if (switch (type exp))
         ((switch (type exp)) exp)
         :nil)))

(print (compile '(def f (fn [x] (def y 42) y))))
(print (compile [:hi :there :buddy!]))
(print (compile {:x 42, :y 69}))
